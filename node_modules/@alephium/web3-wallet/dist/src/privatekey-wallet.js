"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrivateKeyWallet = void 0;
const elliptic_1 = require("elliptic");
const web3_1 = require("@alephium/web3");
const web3_2 = require("@alephium/web3");
const hd_wallet_1 = require("./hd-wallet");
const ec = new elliptic_1.ec('secp256k1');
// In-memory HDWallet for simple use cases.
class PrivateKeyWallet extends web3_1.SignerProviderSimple {
    get nodeProvider() {
        return this._nodeProvider ?? web3_1.web3.getCurrentNodeProvider();
    }
    get explorerProvider() {
        return this._explorerProvider ?? web3_1.web3.getCurrentExplorerProvider();
    }
    unsafeGetSelectedAccount() {
        return Promise.resolve(this.account);
    }
    getPublicKey(address) {
        if (address !== this.address) {
            throw Error('The signer address is invalid');
        }
        return Promise.resolve(this.publicKey);
    }
    get account() {
        return { keyType: this.keyType, address: this.address, publicKey: this.publicKey, group: this.group };
    }
    constructor({ privateKey, keyType, nodeProvider, explorerProvider }) {
        super();
        this.keyType = keyType ?? 'default';
        this.privateKey = privateKey;
        this.publicKey = (0, web3_2.publicKeyFromPrivateKey)(privateKey, this.keyType);
        this.address = (0, web3_2.addressFromPublicKey)(this.publicKey, this.keyType);
        this.group = (0, web3_2.groupOfAddress)(this.address);
        this._nodeProvider = nodeProvider;
        this._explorerProvider = explorerProvider;
    }
    static Random(targetGroup, nodeProvider, keyType) {
        const keyPair = ec.genKeyPair();
        const wallet = new PrivateKeyWallet({
            privateKey: keyPair.getPrivate().toString('hex', 64),
            keyType,
            nodeProvider
        });
        if (targetGroup === undefined || wallet.group === targetGroup) {
            return wallet;
        }
        else {
            return PrivateKeyWallet.Random(targetGroup, nodeProvider, keyType);
        }
    }
    static FromMnemonic({ mnemonic, keyType, addressIndex, passphrase, nodeProvider }) {
        const privateKey = (0, hd_wallet_1.deriveHDWalletPrivateKey)(mnemonic, keyType ?? 'default', addressIndex ?? 0, passphrase);
        return new PrivateKeyWallet({ privateKey, keyType, nodeProvider });
    }
    static FromMnemonicWithGroup(mnemonic, targetGroup, keyType, fromAddressIndex, passphrase, nodeProvider) {
        const [privateKey] = (0, hd_wallet_1.deriveHDWalletPrivateKeyForGroup)(mnemonic, targetGroup, keyType ?? 'default', fromAddressIndex, passphrase);
        return new PrivateKeyWallet({ privateKey, keyType, nodeProvider });
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async signRaw(signerAddress, hexString) {
        if (signerAddress !== this.address) {
            throw Error('Unmatched signer address');
        }
        return PrivateKeyWallet.sign(this.privateKey, hexString, this.keyType);
    }
    static sign(privateKey, hexString, _keyType) {
        return web3_1.utils.sign(hexString, privateKey, _keyType);
    }
}
exports.PrivateKeyWallet = PrivateKeyWallet;
