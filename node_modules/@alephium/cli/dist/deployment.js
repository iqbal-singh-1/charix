"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployToDevnet = exports.deploy = exports.validatePrivateKeys = exports.recordEqual = exports.DeploymentsPerAddress = exports.getDeploymentResults = exports.getDeploymentResult = exports.Deployments = void 0;
const web3_1 = require("@alephium/web3");
const web3_wallet_1 = require("@alephium/web3-wallet");
const path_1 = __importDefault(require("path"));
const fs_1 = __importStar(require("fs"));
const cryptojs = __importStar(require("crypto-js"));
const types_1 = require("./types");
const utils_1 = require("./utils");
const web3_2 = require("@alephium/web3");
const codegen_1 = require("./codegen");
const project_1 = require("./project");
class Deployments {
    constructor(deployments) {
        this.deployments = deployments;
    }
    static empty() {
        return new Deployments([]);
    }
    isEmpty() {
        return this.deployments.length === 0 || this.deployments.every((d) => d.isEmpty());
    }
    deploymentsByGroup(group) {
        return this.deployments.find((deployment) => (0, web3_2.groupOfAddress)(deployment.deployerAddress) === group);
    }
    getDeployedContractResult(group, name) {
        return this.deploymentsByGroup(group)?.contracts.get(name);
    }
    getExecutedScriptResult(group, name) {
        return this.deploymentsByGroup(group)?.scripts.get(name);
    }
    add(deploymentsPerAddress) {
        const index = this.deployments.findIndex((deployment) => deployment.deployerAddress === deploymentsPerAddress.deployerAddress);
        if (index === -1) {
            this.deployments.push(deploymentsPerAddress);
        }
        else {
            this.deployments[`${index}`] = deploymentsPerAddress;
        }
    }
    getByDeployer(deployerAddress) {
        return this.deployments.find((deployment) => deployment.deployerAddress === deployerAddress);
    }
    async saveToFile(filepath, config, deploymentSuccessful) {
        const dirpath = path_1.default.dirname(filepath);
        if (!fs_1.default.existsSync(dirpath)) {
            fs_1.default.mkdirSync(dirpath, { recursive: true });
        }
        const deployments = this.deployments.map((v) => v.marshal());
        const content = JSON.stringify(deployments.length === 1 ? deployments[0] : deployments, (key, value) => {
            if (key === 'contractInstance' && value instanceof web3_1.ContractInstance) {
                return {
                    address: value.address,
                    contractId: value.contractId,
                    groupIndex: value.groupIndex
                };
            }
            return value;
        }, 2);
        await fs_1.promises.writeFile(filepath, content);
        // This needs to be at the end since it will check if the deployments file exists
        if (deploymentSuccessful) {
            try {
                await (0, codegen_1.genLoadDeployments)(config);
            }
            catch (error) {
                console.error(`Failed to generate deployments.ts, error: ${error}`);
            }
        }
    }
    static async from(filepath) {
        if (!fs_1.default.existsSync(filepath)) {
            return Deployments.empty();
        }
        try {
            const content = await fs_1.promises.readFile(filepath);
            const json = JSON.parse(content.toString());
            const objects = Array.isArray(json) ? json : [json];
            return new Deployments(objects.map((object) => DeploymentsPerAddress.unmarshal(object)));
        }
        catch (error) {
            console.error(`Failed to parse deployments, error: ${error}, will re-deploy the contract`);
            return Deployments.empty();
        }
    }
    static async load(configuration, networkId) {
        const deploymentsFile = (0, utils_1.getDeploymentFilePath)(configuration, networkId);
        return Deployments.from(deploymentsFile);
    }
    tryGetDeployedContract(contractName, group, taskId) {
        const deployments = group !== undefined ? this.deploymentsByGroup(group) : this.deployments[0];
        if (deployments === undefined) {
            return undefined;
        }
        return taskId === undefined
            ? deployments.contracts.get(`${contractName}`)
            : deployments.contracts.get(`${(0, utils_1.taskIdToVariable)(taskId)}`);
    }
    getInstance(contract, group, taskId) {
        const result = this.tryGetDeployedContract(contract.contract.name, group, taskId);
        if (result === undefined) {
            return undefined;
        }
        return contract.at(result.contractInstance.address);
    }
}
exports.Deployments = Deployments;
async function getDeploymentResult(filepath) {
    const deployments = await Deployments.from(filepath);
    if (deployments.deployments.length > 1) {
        throw new Error('The contracts has been deployed to multiple groups');
    }
    return deployments.deployments[0];
}
exports.getDeploymentResult = getDeploymentResult;
async function getDeploymentResults(filepath) {
    const deployments = await Deployments.from(filepath);
    return deployments.deployments;
}
exports.getDeploymentResults = getDeploymentResults;
class DeploymentsPerAddress {
    constructor(deployerAddress, contracts, scripts, migrations) {
        this.deployerAddress = deployerAddress;
        this.contracts = contracts;
        this.scripts = scripts;
        this.migrations = migrations;
    }
    static empty(deployerAddress) {
        return new DeploymentsPerAddress(deployerAddress, new Map(), new Map(), new Map());
    }
    isEmpty() {
        return this.contracts.size === 0 && this.scripts.size === 0 && this.migrations.size === 0;
    }
    marshal() {
        return {
            deployerAddress: this.deployerAddress,
            contracts: Object.fromEntries(this.contracts),
            scripts: Object.fromEntries(this.scripts),
            migrations: Object.fromEntries(this.migrations)
        };
    }
    static unmarshal(json) {
        const deployerAddress = json.deployerAddress;
        const contracts = new Map(Object.entries(json.contracts));
        const scripts = new Map(Object.entries(json.scripts));
        const migrations = new Map(Object.entries(json.migrations));
        return new DeploymentsPerAddress(deployerAddress, contracts, scripts, migrations);
    }
}
exports.DeploymentsPerAddress = DeploymentsPerAddress;
async function isTxExists(provider, txId) {
    const txStatus = await provider.transactions.getTransactionsStatus({ txId: txId });
    return txStatus.type !== 'TxNotFound';
}
function recordEqual(left, right) {
    const leftKeys = Object.keys(left);
    const rightKeys = Object.keys(right);
    if (leftKeys.length !== rightKeys.length) {
        return false;
    }
    for (const key of leftKeys) {
        if (left[`${key}`] !== right[`${key}`]) {
            return false;
        }
    }
    return true;
}
exports.recordEqual = recordEqual;
async function needToRetry(provider, previous, attoAlphAmount, tokens, codeHash) {
    if (previous === undefined || previous.codeHash !== codeHash) {
        return true;
    }
    const txExists = await isTxExists(provider, previous.txId);
    if (!txExists) {
        return true;
    }
    const currentTokens = tokens ? tokens : {};
    const previousTokens = previous.tokens ? previous.tokens : {};
    const sameWithPrevious = attoAlphAmount === previous.attoAlphAmount && recordEqual(currentTokens, previousTokens);
    return !sameWithPrevious;
}
async function needToDeployContract(provider, previous, attoAlphAmount, tokens, issueTokenAmount, codeHash) {
    const retry = await needToRetry(provider, previous, attoAlphAmount, tokens, codeHash);
    if (retry) {
        return true;
    }
    // previous !== undefined if retry is false
    return previous.issueTokenAmount !== issueTokenAmount;
}
async function needToRunScript(provider, previous, attoAlphAmount, tokens, codeHash) {
    return needToRetry(provider, previous, attoAlphAmount, tokens, codeHash);
}
function getTokenRecord(tokens) {
    return tokens.reduce((acc, token) => {
        acc[token.id] = token.amount.toString();
        return acc;
    }, {});
}
function getTaskId(code, taskTag) {
    if (taskTag === undefined)
        return code.name;
    const taskTagRegex = new RegExp('^[a-zA-Z0-9_-]*$');
    if (!taskTagRegex.test(taskTag)) {
        throw new Error(`Invalid task tag, the task tag must match the pattern: ${taskTagRegex.source}`);
    }
    return `${code.name}:${taskTag}`;
}
function getDebugLogger(debugModeEnabled) {
    return (message) => {
        if (debugModeEnabled) {
            console.log(message);
        }
    };
}
function getDeploymentLogger(silent) {
    return (message) => {
        if (!silent) {
            console.log(message);
        }
    };
}
function createDeployer(deploymentLogger, debugLogger, network, signer, allDeployments, deployContractResults, runScriptResults, requestInterval) {
    const account = {
        keyType: 'default',
        address: signer.address,
        group: signer.group,
        publicKey: signer.publicKey
    };
    const confirmations = network.confirmations ? network.confirmations : 1;
    const deployedContracts = [];
    const executedScripts = [];
    const deployContractInner = async (contractFactory, params, taskTag) => {
        const initialFields = (0, web3_1.addStdIdToFields)(contractFactory.contract, params.initialFields ?? {});
        const initFieldsAndByteCode = contractFactory.contract.buildByteCodeToDeploy(initialFields, (0, web3_1.isDevnet)(network.networkId));
        const codeHash = cryptojs.SHA256(initFieldsAndByteCode).toString();
        const taskId = getTaskId(contractFactory.contract, taskTag);
        if (deployedContracts.includes(taskId)) {
            throw new Error(`Contract deployment task ${taskId} already exists, please use a new task tag`);
        }
        deployedContracts.push(taskId);
        const previous = deployContractResults.get(taskId);
        const tokens = params.initialTokenAmounts ? getTokenRecord(params.initialTokenAmounts) : undefined;
        const needToDeploy = await needToDeployContract(web3_1.web3.getCurrentNodeProvider(), previous, tryBigIntToString(params.initialAttoAlphAmount), tokens, tryBigIntToString(params.issueTokenAmount), codeHash);
        if (!needToDeploy) {
            // we have checked in `needToDeployContract`
            deploymentLogger(`The deployment of contract ${taskId} is skipped as it has been deployed`);
            const previousDeployResult = previous;
            const contractInstance = contractFactory.at(previousDeployResult.contractInstance.address);
            return {
                ...previousDeployResult,
                contractInstance
            };
        }
        deploymentLogger(`Deploying contract ${taskId}`);
        debugLogger(`Deployer - group ${signer.group} - ${signer.address}`);
        const deployResult = await contractFactory.deploy(signer, params);
        const confirmed = await (0, web3_2.waitForTxConfirmation)(deployResult.txId, confirmations, requestInterval);
        const result = {
            txId: deployResult.txId,
            unsignedTx: deployResult.unsignedTx,
            signature: deployResult.signature,
            gasPrice: deployResult.gasPrice.toString(),
            gasAmount: deployResult.gasAmount,
            blockHash: confirmed.blockHash,
            codeHash: codeHash,
            attoAlphAmount: tryBigIntToString(params.initialAttoAlphAmount),
            tokens: tokens,
            contractInstance: deployResult.contractInstance,
            issueTokenAmount: tryBigIntToString(params.issueTokenAmount)
        };
        deployContractResults.set(taskId, result);
        return deployResult;
    };
    const deployContract = async (contractFactory, params, taskTag) => {
        return deployContractInner(contractFactory, params, taskTag);
    };
    const deployContractTemplate = async (contractFactory, taskTag) => {
        const params = {
            initialFields: contractFactory.contract.getInitialFieldsWithDefaultValues()
        };
        return deployContractInner(contractFactory, params, taskTag);
    };
    const runScript = async (executableScript, params, taskTag) => {
        const initFieldsAndByteCode = executableScript.script.buildByteCodeToDeploy(params.initialFields ?? {});
        const codeHash = cryptojs.SHA256(initFieldsAndByteCode).toString();
        const taskId = getTaskId(executableScript.script, taskTag);
        if (executedScripts.includes(taskId)) {
            throw new Error(`Run script task ${taskId} already exists, please use a new task tag`);
        }
        executedScripts.push(taskId);
        const previous = runScriptResults.get(taskId);
        const tokens = params.tokens ? getTokenRecord(params.tokens) : undefined;
        const needToRun = await needToRunScript(web3_1.web3.getCurrentNodeProvider(), previous, tryBigIntToString(params.attoAlphAmount), tokens, codeHash);
        if (!needToRun) {
            // we have checked in `needToRunScript`
            deploymentLogger(`The execution of script ${taskId} is skipped as it has been executed`);
            const previousExecuteResult = previous;
            return { ...previousExecuteResult };
        }
        deploymentLogger(`Executing script ${taskId}`);
        const executeResult = await executableScript.execute(signer, params);
        const confirmed = await (0, web3_2.waitForTxConfirmation)(executeResult.txId, confirmations, requestInterval);
        const runScriptResult = {
            ...executeResult,
            gasPrice: executeResult.gasPrice.toString(),
            blockHash: confirmed.blockHash,
            codeHash: codeHash,
            attoAlphAmount: tryBigIntToString(params.attoAlphAmount),
            tokens: tokens
        };
        runScriptResults.set(taskId, runScriptResult);
        return executeResult;
    };
    const getDeployContractResult = (name) => {
        const result = deployContractResults.get(name);
        if (result === undefined) {
            throw new Error(`Deployment result of contract "${name}" does not exist`);
        }
        return result;
    };
    const getRunScriptResult = (name) => {
        const result = runScriptResults.get(name);
        if (result === undefined) {
            throw new Error(`Execution result of script "${name}" does not exist`);
        }
        return result;
    };
    const getDeployContractResultFromGroup = (name, group) => {
        const deployments = allDeployments.deployments.find((d) => (0, web3_2.groupOfAddress)(d.deployerAddress) === group);
        if (deployments === undefined) {
            throw new Error(`Deployment result of contract "${name}" does not exist in group ${group}`);
        }
        const result = deployments.contracts.get(name);
        if (result === undefined) {
            throw new Error(`Deployment result of contract "${name}" does not exist in group ${group}`);
        }
        return result;
    };
    return {
        provider: web3_1.web3.getCurrentNodeProvider(),
        account: account,
        deployContract: deployContract,
        deployContractTemplate: deployContractTemplate,
        runScript: runScript,
        getDeployContractResult: getDeployContractResult,
        getRunScriptResult: getRunScriptResult,
        getDeployContractResultFromGroup
    };
}
async function getDeployScriptFiles(rootPath) {
    const regex = '^([0-9]+)_.*\\.(ts|js)$';
    const dirents = await fs_1.promises.readdir(rootPath, { withFileTypes: true });
    const scripts = [];
    for (const f of dirents) {
        if (!f.isFile())
            continue;
        const result = f.name.match(regex);
        if (result === null)
            continue;
        const order = parseInt(result[1]);
        scripts.push({ filename: f.name, order: order });
    }
    scripts.sort((a, b) => a.order - b.order);
    for (let i = 0; i < scripts.length; i++) {
        if (scripts[`${i}`].order !== i) {
            throw new Error('Script should begin with number prefix that consecutively starts from 0');
        }
    }
    return scripts.map((f) => path_1.default.join(rootPath, f.filename));
}
async function validateChainParams(networkId, groups) {
    const chainParams = await web3_1.web3.getCurrentNodeProvider().infos.getInfosChainParams();
    if (chainParams.networkId !== networkId) {
        throw new Error(`The node chain id ${chainParams.networkId} is different from configured chain id ${networkId}`);
    }
    if (groups.some((group, index) => groups.indexOf(group) !== index)) {
        throw new Error(`Found duplicated groups in: ${groups}`);
    }
    if (groups.length > chainParams.groups) {
        throw new Error(`The number of group cannot larger than ${chainParams.groups}`);
    }
    if (groups.some((group) => group >= chainParams.groups || group < 0)) {
        throw new Error(`Group indexes should be subset of [${[...Array(chainParams.groups).keys()]}]`);
    }
}
function validatePrivateKeys(privateKeys) {
    const pks = typeof privateKeys === 'string' ? privateKeys.split(',') : privateKeys;
    if (pks.length === 0 || privateKeys === '') {
        throw new Error('No private key specified');
    }
    const signers = pks.map((privateKey, index) => {
        if ((0, web3_1.isHexString)(privateKey) && privateKey.length === 64) {
            return new web3_wallet_1.PrivateKeyWallet({ privateKey });
        }
        throw new Error(`Invalid private key at index ${index}, expected a hex-string of length 64`);
    });
    const groups = signers.map((signer) => signer.group);
    const sameGroups = groups.filter((group, index) => groups.indexOf(group) !== index);
    if (sameGroups.length > 0) {
        throw new Error(`Duplicated private keys on group ${sameGroups}`);
    }
    return signers;
}
exports.validatePrivateKeys = validatePrivateKeys;
function tryGetScriptsFromRange(scripts, fromIndex, toIndex) {
    const from = fromIndex ?? 0;
    const to = toIndex ?? scripts.length - 1;
    if (from > to) {
        throw new Error('The from index must not be greater than the to index');
    }
    if (from < 0 || to > scripts.length - 1) {
        throw new Error(`Invalid script range: [${from}, ${to}]`);
    }
    return scripts.slice(from, to + 1);
}
async function deploy(configuration, networkId, deployments, fromIndex, toIndex, silent = false) {
    const network = (0, utils_1.getNetwork)(configuration, networkId);
    if (typeof network === 'undefined') {
        throw new Error(`no network ${networkId} config`);
    }
    web3_1.web3.setCurrentNodeProvider(network.nodeUrl, undefined, utils_1.retryFetch);
    const projectRootDir = path_1.default.resolve(process.cwd());
    const prevProjectArtifact = await project_1.ProjectArtifact.from(projectRootDir);
    const artifactDir = configuration.artifactDir ?? types_1.DEFAULT_CONFIGURATION_VALUES.artifactDir;
    let project = undefined;
    if (configuration.skipRecompile !== true) {
        const forceRecompile = configuration.forceRecompile || !(0, utils_1.isDeployed)(configuration);
        project = await project_1.Project.compile(configuration.compilerOptions, path_1.default.resolve(process.cwd()), configuration.sourceDir ?? types_1.DEFAULT_CONFIGURATION_VALUES.sourceDir, artifactDir, undefined, forceRecompile);
    }
    // When the contract has been deployed previously, and the contract
    // code has changed, ask the user to confirm whether to redeploy the contract
    if (!deployments.isEmpty() &&
        prevProjectArtifact !== undefined &&
        project !== undefined &&
        project_1.ProjectArtifact.isCodeChanged(project.projectArtifact, prevProjectArtifact)) {
        // We need to regenerate the code because the deployment scripts depend on the generated ts code
        (0, codegen_1.codegen)(project);
        const msg = 'The contract code has been changed, which will result in redeploying the contract.\nPlease confirm if you want to proceed?';
        if (!(await (0, utils_1.waitUserConfirmation)(msg))) {
            return false;
        }
    }
    const deployScriptsRootPath = configuration.deploymentScriptDir
        ? configuration.deploymentScriptDir
        : types_1.DEFAULT_CONFIGURATION_VALUES.deploymentScriptDir;
    const allScriptFiles = await getDeployScriptFiles(path_1.default.resolve(deployScriptsRootPath));
    const scriptFiles = tryGetScriptsFromRange(allScriptFiles, fromIndex, toIndex);
    const scripts = [];
    for (const scriptFilePath of scriptFiles) {
        try {
            /* eslint-disable @typescript-eslint/no-var-requires */
            const content = require(scriptFilePath);
            /* eslint-enable @typescript-eslint/no-var-requires */
            if (content.default) {
                scripts.push({
                    scriptFilePath: scriptFilePath,
                    func: content.default
                });
            }
            else {
                throw new Error(`No default deploy function exported from ${scriptFilePath}`);
            }
        }
        catch (error) {
            throw new web3_1.TraceableError(`Failed to load deploy script, filepath: ${scriptFilePath}`, error);
        }
    }
    const signers = validatePrivateKeys(network.privateKeys);
    await validateChainParams(network.networkId, signers.map((signer) => signer.group));
    const inParallel = configuration.deployToMultipleGroupsInParallel ?? types_1.DEFAULT_CONFIGURATION_VALUES.deployToMultipleGroupsInParallel;
    if (inParallel && signers.length > 1) {
        await deployInParallel(signers, deployments, networkId, configuration, network, scripts, silent);
    }
    else {
        await deployInSequential(signers, deployments, networkId, configuration, network, scripts, silent);
    }
    return true;
}
exports.deploy = deploy;
async function deployInSequential(signers, deployments, networkId, configuration, networkSettings, scripts, silent) {
    for (const signer of signers) {
        const deploymentsPerAddress = deployments.getByDeployer(signer.address) ?? DeploymentsPerAddress.empty(signer.address);
        deployments.add(deploymentsPerAddress);
        await deployToGroup(networkId, configuration, deployments, deploymentsPerAddress, signer, networkSettings, scripts, silent);
    }
}
async function deployInParallel(signers, deployments, networkId, configuration, networkSettings, scripts, silent) {
    const promises = signers.map((signer) => {
        const deploymentsPerAddress = deployments.getByDeployer(signer.address) ?? DeploymentsPerAddress.empty(signer.address);
        deployments.add(deploymentsPerAddress);
        return deployToGroup(networkId, configuration, deployments, deploymentsPerAddress, signer, networkSettings, scripts, silent);
    });
    const results = await Promise.allSettled(promises);
    const rejected = results
        .map((result, index) => ({ result, index }))
        .filter((v) => v.result.status === 'rejected');
    if (rejected.length !== 0) {
        const errorMsg = rejected
            .map((v) => {
            const group = signers[v.index].group;
            return `failed to deploy to group ${group}, reason: ${v.result.reason}`;
        })
            .join('\n');
        throw new Error(errorMsg);
    }
}
async function deployToDevnet(silent = false) {
    const deployments = Deployments.empty();
    const configuration = (0, utils_1.loadConfig)((0, utils_1.getConfigFile)());
    await deploy(configuration, 'devnet', deployments, undefined, undefined, silent);
    return deployments;
}
exports.deployToDevnet = deployToDevnet;
async function deployToGroup(networkId, configuration, allDeployments, deployments, signer, network, scripts, silent) {
    const requestInterval = networkId === 'devnet' ? 1000 : 10000;
    const deploymentLogger = getDeploymentLogger(silent);
    const deployer = createDeployer(deploymentLogger, getDebugLogger(configuration.enableDebugMode ?? false), network, signer, allDeployments, deployments.contracts, deployments.scripts, requestInterval);
    for (const script of scripts) {
        try {
            if (script.func.id && deployments.migrations.get(script.func.id) !== undefined) {
                deploymentLogger(`Skipping ${script.scriptFilePath} as the script already executed and complete`);
                continue;
            }
            let skip = false;
            if (script.func.skip !== undefined) {
                skip = await script.func.skip(configuration, networkId);
            }
            if (skip) {
                deploymentLogger(`Skip the execution of ${script.scriptFilePath}`);
                continue;
            }
            const result = await script.func(deployer, network);
            if (result && typeof result === 'boolean') {
                if (script.func.id === undefined) {
                    throw new Error(`${script.scriptFilePath} return true to not be executed again, but does not provide an id. The script function needs to have the field "id" to be set`);
                }
                deployments.migrations.set(script.func.id, Date.now());
            }
        }
        catch (error) {
            throw new web3_1.TraceableError(`Failed to execute deploy script, filepath: ${script.scriptFilePath}`, error);
        }
    }
}
function tryBigIntToString(num) {
    return num === undefined ? undefined : num.toString();
}
