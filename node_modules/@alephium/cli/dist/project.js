"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Project = exports.ProjectArtifact = exports.SourceInfo = void 0;
const web3_1 = require("@alephium/web3");
const path = __importStar(require("path"));
const fs_1 = __importDefault(require("fs"));
const fs_2 = require("fs");
const error_1 = require("./error");
const crypto = new web3_1.WebCrypto();
class TypedMatcher {
    constructor(pattern, type) {
        this.matcher = new RegExp(pattern, 'mg');
        this.type = type;
    }
}
function removeParentsPrefix(parts) {
    let index = 0;
    for (let i = 0; i < parts.length; i++) {
        if (parts[`${i}`] === '..') {
            index += 1;
        }
        else {
            break;
        }
    }
    return path.join(...parts.slice(index));
}
var SourceKind;
(function (SourceKind) {
    SourceKind[SourceKind["Contract"] = 0] = "Contract";
    SourceKind[SourceKind["Script"] = 1] = "Script";
    SourceKind[SourceKind["AbstractContract"] = 2] = "AbstractContract";
    SourceKind[SourceKind["Interface"] = 3] = "Interface";
    SourceKind[SourceKind["Struct"] = 4] = "Struct";
    SourceKind[SourceKind["Constants"] = 5] = "Constants";
})(SourceKind || (SourceKind = {}));
class SourceInfo {
    constructor(type, name, sourceCode, sourceCodeHash, contractRelativePath, isExternal) {
        this.type = type;
        this.name = name;
        this.sourceCode = sourceCode;
        this.sourceCodeHash = sourceCodeHash;
        this.contractRelativePath = contractRelativePath;
        this.isExternal = isExternal;
    }
    getArtifactPath(artifactsRootDir) {
        let fullPath;
        if (this.isExternal) {
            const relativePath = removeParentsPrefix(this.contractRelativePath.split(path.sep));
            const externalPath = path.join('.external', relativePath);
            fullPath = path.join(artifactsRootDir, externalPath);
        }
        else {
            fullPath = path.join(artifactsRootDir, this.contractRelativePath);
        }
        return path.join(path.dirname(fullPath), `${this.name}.ral.json`);
    }
    static async from(type, name, sourceCode, contractRelativePath, isExternal) {
        const sourceCodeHash = await crypto.subtle.digest('SHA-256', Buffer.from(sourceCode));
        const sourceCodeHashHex = Buffer.from(sourceCodeHash).toString('hex');
        return new SourceInfo(type, name, sourceCode, sourceCodeHashHex, contractRelativePath, isExternal);
    }
}
exports.SourceInfo = SourceInfo;
class Compiled {
    constructor(sourceInfo, artifact, warnings) {
        this.sourceInfo = sourceInfo;
        this.artifact = artifact;
        this.warnings = warnings;
    }
}
function findSourceInfoAtLineNumber(sources, line) {
    let currentLine = 0;
    const sourceInfosWithLine = sources.map((source) => {
        const startIndex = currentLine + 1;
        currentLine += source.sourceCode.split('\n').length;
        const endIndex = currentLine;
        return { sourceInfo: source, startIndex: startIndex, endIndex: endIndex };
    });
    const sourceInfo = sourceInfosWithLine.find((sourceInfoWithLine) => {
        return line >= sourceInfoWithLine.startIndex && line <= sourceInfoWithLine.endIndex;
    });
    return sourceInfo;
}
class ProjectArtifact {
    constructor(fullNodeVersion, compilerOptionsUsed, infos) {
        ProjectArtifact.checkCompilerOptionsParameter(compilerOptionsUsed);
        this.fullNodeVersion = fullNodeVersion;
        this.compilerOptionsUsed = compilerOptionsUsed;
        this.infos = infos;
    }
    static checkCompilerOptionsParameter(compilerOptions) {
        if (Object.keys(compilerOptions).length != Object.keys(web3_1.DEFAULT_NODE_COMPILER_OPTIONS).length) {
            throw Error(`Not all compiler options are set: ${compilerOptions}`);
        }
        const combined = { ...compilerOptions, ...web3_1.DEFAULT_NODE_COMPILER_OPTIONS };
        if (Object.keys(combined).length !== Object.keys(web3_1.DEFAULT_NODE_COMPILER_OPTIONS).length) {
            throw Error(`There are unknown compiler options: ${compilerOptions}`);
        }
    }
    static isCodeChanged(current, previous) {
        if (current.infos.size !== previous.infos.size) {
            return true;
        }
        for (const [name, codeInfo] of current.infos) {
            const prevCodeInfo = previous.infos.get(name);
            if (prevCodeInfo?.codeHashDebug !== codeInfo.codeHashDebug) {
                return true;
            }
        }
        return false;
    }
    async saveToFile(rootPath) {
        const filepath = path.join(rootPath, ProjectArtifact.artifactFileName);
        const artifact = {
            fullNodeVersion: this.fullNodeVersion,
            compilerOptionsUsed: this.compilerOptionsUsed,
            infos: Object.fromEntries(new Map([...this.infos].sort()))
        };
        const content = JSON.stringify(artifact, null, 2);
        return fs_2.promises.writeFile(filepath, content);
    }
    getChangedSources(sourceInfos) {
        const result = [];
        // get all changed and new sources
        sourceInfos.forEach((sourceInfo) => {
            const info = this.infos.get(sourceInfo.name);
            if (info === undefined || info.sourceCodeHash !== sourceInfo.sourceCodeHash) {
                result.push(sourceInfo.name);
            }
        });
        // get all removed sources
        this.infos.forEach((_, name) => {
            if (sourceInfos.find((s) => s.name === name) === undefined) {
                result.push(name);
            }
        });
        return result;
    }
    needToReCompile(compilerOptions, fullNodeVersion) {
        ProjectArtifact.checkCompilerOptionsParameter(compilerOptions);
        if (this.fullNodeVersion !== fullNodeVersion) {
            return true;
        }
        const optionsMatched = Object.entries(compilerOptions).every(([key, inputOption]) => {
            const usedOption = this.compilerOptionsUsed[`${key}`];
            return usedOption === inputOption;
        });
        if (!optionsMatched) {
            return true;
        }
        return false;
    }
    static async from(rootPath) {
        const filepath = path.join(rootPath, ProjectArtifact.artifactFileName);
        if (!fs_1.default.existsSync(filepath)) {
            return undefined;
        }
        try {
            const content = await fs_2.promises.readFile(filepath);
            const json = JSON.parse(content.toString());
            const fullNodeVersion = json.fullNodeVersion;
            const compilerOptionsUsed = { ...web3_1.DEFAULT_NODE_COMPILER_OPTIONS };
            Object.entries(json.compilerOptionsUsed).forEach(([key, value]) => {
                compilerOptionsUsed[`${key}`] = value;
            });
            const files = new Map(Object.entries(json.infos));
            return new ProjectArtifact(fullNodeVersion, compilerOptionsUsed, files);
        }
        catch (error) {
            console.error(`Failed to load project artifact, error: ${error}`);
            return undefined;
        }
    }
}
exports.ProjectArtifact = ProjectArtifact;
ProjectArtifact.artifactFileName = '.project.json';
function removeOldArtifacts(dir, sourceFiles) {
    const files = fs_1.default.readdirSync(dir);
    const hasConstant = sourceFiles.find((s) => s.type === SourceKind.Constants) !== undefined;
    const hasStruct = sourceFiles.find((s) => s.type === SourceKind.Struct) !== undefined;
    files.forEach((file) => {
        const filePath = path.join(dir, file);
        const stat = fs_1.default.statSync(filePath);
        if (stat.isDirectory()) {
            removeOldArtifacts(filePath, sourceFiles);
        }
        else if (filePath.endsWith(Project.constantArtifactFileName)) {
            if (!hasConstant)
                fs_1.default.unlinkSync(filePath);
        }
        else if (filePath.endsWith(Project.structArtifactFileName)) {
            if (!hasStruct)
                fs_1.default.unlinkSync(filePath);
        }
        else if (filePath.endsWith('.ral.json') || filePath.endsWith('.ral')) {
            const filename = path.basename(filePath);
            const artifactName = filename.slice(0, filename.indexOf('.'));
            const sourceFile = sourceFiles.find((s) => s.name === artifactName && (s.type === SourceKind.Contract || s.type === SourceKind.Script));
            if (sourceFile === undefined) {
                fs_1.default.unlinkSync(filePath);
            }
        }
    });
    if (fs_1.default.readdirSync(dir).length === 0) {
        fs_1.default.rmdirSync(dir);
    }
}
class Project {
    constructor(contractsRootDir, artifactsRootDir, sourceInfos, contracts, scripts, structs, constants, enums, projectArtifact) {
        this.contractsRootDir = contractsRootDir;
        this.artifactsRootDir = artifactsRootDir;
        this.sourceInfos = sourceInfos;
        this.contracts = contracts;
        this.scripts = scripts;
        this.structs = structs;
        this.constants = constants;
        this.enums = enums;
        this.projectArtifact = projectArtifact;
    }
    static buildProjectArtifact(fullNodeVersion, sourceInfos, contracts, scripts, compilerOptions) {
        const files = new Map();
        contracts.forEach((c) => {
            files.set(c.artifact.name, {
                sourceFile: c.sourceInfo.contractRelativePath,
                sourceCodeHash: c.sourceInfo.sourceCodeHash,
                bytecodeDebugPatch: c.artifact.bytecodeDebugPatch,
                codeHashDebug: c.artifact.codeHashDebug
            });
        });
        scripts.forEach((s) => {
            files.set(s.artifact.name, {
                sourceFile: s.sourceInfo.contractRelativePath,
                sourceCodeHash: s.sourceInfo.sourceCodeHash,
                bytecodeDebugPatch: s.artifact.bytecodeDebugPatch,
                codeHashDebug: ''
            });
        });
        const compiledSize = contracts.size + scripts.size;
        sourceInfos.slice(compiledSize).forEach((c) => {
            files.set(c.name, {
                sourceFile: c.contractRelativePath,
                sourceCodeHash: c.sourceCodeHash,
                bytecodeDebugPatch: '',
                codeHashDebug: ''
            });
        });
        return new ProjectArtifact(fullNodeVersion, compilerOptions, files);
    }
    static checkCompilerWarnings(contracts, scripts, globalWarnings, changedSources, forceRecompile, errorOnWarnings) {
        const warnings = forceRecompile ? globalWarnings : [];
        contracts.forEach((contract) => {
            if (Project.needToUpdate(forceRecompile, changedSources, contract.sourceInfo.name)) {
                warnings.push(...contract.warnings);
            }
        });
        scripts.forEach((script) => {
            if (Project.needToUpdate(forceRecompile, changedSources, script.sourceInfo.name)) {
                warnings.push(...script.warnings);
            }
        });
        if (warnings.length !== 0) {
            const prefixPerWarning = '  - ';
            const warningString = prefixPerWarning + warnings.join('\n' + prefixPerWarning);
            const output = `Compilation warnings:\n` + warningString + '\n';
            if (errorOnWarnings) {
                throw new Error(output);
            }
            else {
                console.log(output);
            }
        }
    }
    contract(name) {
        const contract = this.contracts.get(name);
        if (typeof contract === 'undefined') {
            throw new Error(`Contract "${name}" does not exist`);
        }
        return contract.artifact;
    }
    script(name) {
        const script = this.scripts.get(name);
        if (typeof script === 'undefined') {
            throw new Error(`Script "${name}" does not exist`);
        }
        return script.artifact;
    }
    static async loadStructs(artifactsRootDir) {
        const filePath = path.join(artifactsRootDir, Project.structArtifactFileName);
        if (!fs_1.default.existsSync(filePath))
            return [];
        const content = await fs_2.promises.readFile(filePath);
        const json = JSON.parse(content.toString());
        if (!Array.isArray(json)) {
            throw Error(`Invalid structs JSON: ${content}`);
        }
        return Array.from(json).map((item) => web3_1.Struct.fromJson(item));
    }
    async saveStructsToFile() {
        if (this.structs.length === 0)
            return;
        const structs = this.structs.map((s) => s.toJson());
        const filePath = path.join(this.artifactsRootDir, Project.structArtifactFileName);
        return fs_2.promises.writeFile(filePath, JSON.stringify(structs, null, 2));
    }
    static async loadConstants(artifactsRootDir) {
        const filePath = path.join(artifactsRootDir, Project.constantArtifactFileName);
        if (!fs_1.default.existsSync(filePath))
            return { constants: [], enums: [] };
        const content = await fs_2.promises.readFile(filePath);
        const json = JSON.parse(content.toString());
        let result = { constants: [], enums: [] };
        if (json.constants)
            result = { ...result, constants: json.constants };
        if (json.enums)
            result = { ...result, enums: json.enums };
        return result;
    }
    async saveConstantsToFile() {
        if (this.constants.length === 0 && this.enums.length === 0)
            return;
        const object = {};
        if (this.constants.length !== 0) {
            object['constants'] = this.constants;
        }
        if (this.enums.length !== 0) {
            object['enums'] = this.enums;
        }
        const filePath = path.join(this.artifactsRootDir, 'constants.ral.json');
        return fs_2.promises.writeFile(filePath, JSON.stringify(object, null, 2));
    }
    static needToUpdate(forceRecompile, changedSources, name) {
        return forceRecompile || changedSources.includes(name);
    }
    async checkMethodIndex(newArtifact) {
        const artifactPath = newArtifact.sourceInfo.getArtifactPath(this.artifactsRootDir);
        let oldArtifact;
        try {
            oldArtifact = await web3_1.Contract.fromArtifactFile(artifactPath, '', '');
        }
        catch (error) {
            throw new web3_1.TraceableError(`Failed to load contract artifact, contract: ${newArtifact.sourceInfo.name}`, error);
        }
        newArtifact.artifact.functions.forEach((newFuncSig, index) => {
            const oldFuncSig = oldArtifact.functions[`${index}`];
            if (oldFuncSig.name !== newFuncSig.name) {
                throw new Error(`The newly compiled contract ${newArtifact.artifact.name} has different method indexes compared to the existing deployment on mainnet/testnet`);
            }
        });
    }
    async saveArtifactsToFile(projectRootDir, forceRecompile, changedSources) {
        const artifactsRootDir = this.artifactsRootDir;
        const saveToFile = async function (compiled) {
            const artifactPath = compiled.sourceInfo.getArtifactPath(artifactsRootDir);
            const dirname = path.dirname(artifactPath);
            if (!fs_1.default.existsSync(dirname)) {
                fs_1.default.mkdirSync(dirname, { recursive: true });
            }
            return fs_2.promises.writeFile(artifactPath, compiled.artifact.toString());
        };
        for (const [_, contract] of this.contracts) {
            if (Project.needToUpdate(forceRecompile, changedSources, contract.sourceInfo.name)) {
                await saveToFile(contract);
            }
            else {
                await this.checkMethodIndex(contract);
            }
        }
        for (const [_, script] of this.scripts) {
            if (Project.needToUpdate(forceRecompile, changedSources, script.sourceInfo.name)) {
                await saveToFile(script);
            }
        }
        await this.saveStructsToFile();
        await this.saveConstantsToFile();
        await this.saveProjectArtifact(projectRootDir, forceRecompile, changedSources);
    }
    async saveProjectArtifact(projectRootDir, forceRecompile, changedSources) {
        if (!forceRecompile) {
            // we should not update the `codeHashDebug` if the `forceRecompile` is disable
            const prevProjectArtifact = await ProjectArtifact.from(projectRootDir);
            if (prevProjectArtifact !== undefined) {
                for (const [name, info] of this.projectArtifact.infos) {
                    if (!changedSources.includes(name)) {
                        const prevInfo = prevProjectArtifact.infos.get(name);
                        info.bytecodeDebugPatch = prevInfo?.bytecodeDebugPatch ?? info.bytecodeDebugPatch;
                        info.codeHashDebug = prevInfo?.codeHashDebug ?? info.codeHashDebug;
                    }
                }
            }
        }
        await this.projectArtifact.saveToFile(projectRootDir);
    }
    contractByCodeHash(codeHash) {
        const contract = [...this.contracts.values()].find((c) => c.artifact.codeHash === codeHash || c.artifact.codeHashDebug == codeHash);
        if (typeof contract === 'undefined') {
            throw new Error(`Unknown code with code hash: ${codeHash}`);
        }
        return contract.artifact;
    }
    static async getCompileResult(provider, compilerOptions, sources) {
        try {
            const sourceStr = sources.map((f) => f.sourceCode).join('\n');
            return await provider.contracts.postContractsCompileProject({
                code: sourceStr,
                compilerOptions: compilerOptions
            });
        }
        catch (error) {
            const traceableError = new web3_1.TraceableError('Failed to compile the project', error);
            if (!(error instanceof Error)) {
                throw traceableError;
            }
            const parsed = (0, error_1.parseError)(error.message);
            if (!parsed) {
                throw traceableError;
            }
            const sourceInfo = findSourceInfoAtLineNumber(sources, parsed.lineStart);
            if (!sourceInfo) {
                throw traceableError;
            }
            const shiftIndex = parsed.lineStart - sourceInfo.startIndex + 1;
            const newError = parsed.reformat(shiftIndex, sourceInfo.sourceInfo.contractRelativePath);
            throw new Error(newError);
        }
    }
    static async compile_(fullNodeVersion, provider, sourceInfos, projectRootDir, contractsRootDir, artifactsRootDir, errorOnWarnings, compilerOptions, changedSources, forceRecompile) {
        const removeDuplicates = sourceInfos.reduce((acc, sourceInfo) => {
            if (acc.find((info) => info.sourceCodeHash === sourceInfo.sourceCodeHash) === undefined) {
                acc.push(sourceInfo);
            }
            return acc;
        }, []);
        const result = await Project.getCompileResult(provider, compilerOptions, removeDuplicates);
        const contracts = new Map();
        const scripts = new Map();
        const structs = result.structs === undefined ? [] : result.structs.map((item) => web3_1.Struct.fromStructSig(item));
        result.contracts.forEach((contractResult) => {
            const sourceInfo = sourceInfos.find((sourceInfo) => sourceInfo.type === SourceKind.Contract && sourceInfo.name === contractResult.name);
            if (sourceInfo === undefined) {
                // this should never happen
                throw new Error(`SourceInfo does not exist for contract ${contractResult.name}`);
            }
            const contract = web3_1.Contract.fromCompileResult(contractResult, structs);
            contracts.set(contract.name, new Compiled(sourceInfo, contract, contractResult.warnings));
        });
        result.scripts.forEach((scriptResult) => {
            const sourceInfo = sourceInfos.find((sourceInfo) => sourceInfo.type === SourceKind.Script && sourceInfo.name === scriptResult.name);
            if (sourceInfo === undefined) {
                // this should never happen
                throw new Error(`SourceInfo does not exist for script ${scriptResult.name}`);
            }
            const script = web3_1.Script.fromCompileResult(scriptResult, structs);
            scripts.set(script.name, new Compiled(sourceInfo, script, scriptResult.warnings));
        });
        const projectArtifact = Project.buildProjectArtifact(fullNodeVersion, sourceInfos, contracts, scripts, compilerOptions);
        Project.checkCompilerWarnings(contracts, scripts, result.warnings ?? [], changedSources, forceRecompile, errorOnWarnings);
        const project = new Project(contractsRootDir, artifactsRootDir, sourceInfos, contracts, scripts, structs, result.constants ?? [], result.enums ?? [], projectArtifact);
        await project.saveArtifactsToFile(projectRootDir, forceRecompile, changedSources);
        return project;
    }
    static async loadArtifacts(provider, sourceInfos, projectRootDir, contractsRootDir, artifactsRootDir, errorOnWarnings, compilerOptions, changedSources, forceRecompile) {
        const projectArtifact = await ProjectArtifact.from(projectRootDir);
        if (projectArtifact === undefined) {
            throw Error('Failed to load project artifact');
        }
        try {
            const contracts = new Map();
            const scripts = new Map();
            const structs = await Project.loadStructs(artifactsRootDir);
            const constants = await Project.loadConstants(artifactsRootDir);
            for (const sourceInfo of sourceInfos) {
                const info = projectArtifact.infos.get(sourceInfo.name);
                if (typeof info === 'undefined') {
                    throw Error(`Unable to find project info for ${sourceInfo.name}, please rebuild the project`);
                }
                const artifactDir = sourceInfo.getArtifactPath(artifactsRootDir);
                if (sourceInfo.type === SourceKind.Contract) {
                    const artifact = await web3_1.Contract.fromArtifactFile(artifactDir, info.bytecodeDebugPatch, info.codeHashDebug, structs);
                    contracts.set(artifact.name, new Compiled(sourceInfo, artifact, []));
                }
                else if (sourceInfo.type === SourceKind.Script) {
                    const artifact = await web3_1.Script.fromArtifactFile(artifactDir, info.bytecodeDebugPatch, structs);
                    scripts.set(artifact.name, new Compiled(sourceInfo, artifact, []));
                }
            }
            return new Project(contractsRootDir, artifactsRootDir, sourceInfos, contracts, scripts, structs, constants.constants, constants.enums, projectArtifact);
        }
        catch (error) {
            console.log(`Failed to load artifacts, error: ${error}, try to re-compile contracts...`);
            return Project.compile_(projectArtifact.fullNodeVersion, provider, sourceInfos, projectRootDir, contractsRootDir, artifactsRootDir, errorOnWarnings, compilerOptions, changedSources, forceRecompile);
        }
    }
    static getImportSourcePath(projectRootDir, importPath) {
        const parts = importPath.split('/');
        if (parts.length > 1 && parts[0] === 'std') {
            const currentDir = path.dirname(__filename);
            return path.join(...[currentDir, '..', '..', 'web3', importPath]);
        }
        let moduleDir = projectRootDir;
        while (true) {
            const expectedPath = path.join(...[moduleDir, 'node_modules', importPath]);
            if (fs_1.default.existsSync(expectedPath)) {
                return expectedPath;
            }
            const oldModuleDir = moduleDir;
            moduleDir = path.join(moduleDir, '..');
            if (oldModuleDir === moduleDir) {
                throw new Error(`Specified import file does not exist: ${importPath}`);
            }
        }
    }
    static async handleImports(projectRootDir, contractRootDir, sourceStr, importsCache) {
        const localImportsCache = [];
        const result = sourceStr.replace(Project.importRegex, (match) => {
            localImportsCache.push(match);
            return '';
        });
        const externalSourceInfos = [];
        for (const myImport of localImportsCache) {
            const originImportPath = myImport.slice(8, -1);
            const importPath = originImportPath.endsWith('.ral') ? originImportPath : originImportPath + '.ral';
            if (!importsCache.includes(importPath)) {
                importsCache.push(importPath);
                const sourcePath = Project.getImportSourcePath(projectRootDir, importPath);
                const sourceInfos = await Project.loadSourceFile(projectRootDir, contractRootDir, sourcePath, importsCache, true);
                externalSourceInfos.push(...sourceInfos);
            }
        }
        return [result, externalSourceInfos];
    }
    static async loadSourceFile(projectRootDir, contractsRootDir, sourcePath, importsCache, isExternal) {
        const contractRelativePath = path.relative(contractsRootDir, sourcePath);
        if (!sourcePath.endsWith('.ral')) {
            throw new Error(`Invalid filename: ${sourcePath}, smart contract file name should end with ".ral"`);
        }
        const sourceBuffer = await fs_2.promises.readFile(sourcePath);
        const [sourceStr, externalSourceInfos] = await Project.handleImports(projectRootDir, contractsRootDir, sourceBuffer.toString(), importsCache);
        if (sourceStr.match(new RegExp('^import "', 'mg')) !== null) {
            throw new Error(`Invalid import statements, source: ${sourcePath}`);
        }
        const sourceInfos = externalSourceInfos;
        let isConstantsFile = true;
        for (const matcher of this.matchers) {
            const results = Array.from(sourceStr.matchAll(matcher.matcher));
            if (isConstantsFile)
                isConstantsFile = results.length === 0;
            for (const result of results) {
                const sourceInfo = await SourceInfo.from(matcher.type, result[1], sourceStr, contractRelativePath, isExternal);
                sourceInfos.push(sourceInfo);
            }
        }
        if (isConstantsFile) {
            const name = path.basename(sourcePath, path.extname(sourcePath));
            sourceInfos.push(await SourceInfo.from(SourceKind.Constants, name, sourceStr, contractRelativePath, false));
        }
        return sourceInfos;
    }
    static async loadSourceFiles(projectRootDir, contractsRootDir) {
        const importsCache = [];
        const sourceInfos = [];
        const loadDir = async function (dirPath) {
            const dirents = await fs_2.promises.readdir(dirPath, { withFileTypes: true });
            for (const dirent of dirents) {
                if (dirent.isFile()) {
                    const sourcePath = path.join(dirPath, dirent.name);
                    const infos = await Project.loadSourceFile(projectRootDir, contractsRootDir, sourcePath, importsCache, false);
                    sourceInfos.push(...infos);
                }
                else {
                    const newPath = path.join(dirPath, dirent.name);
                    await loadDir(newPath);
                }
            }
        };
        await loadDir(contractsRootDir);
        const contractAndScriptSize = sourceInfos.filter((f) => f.type === SourceKind.Contract || f.type === SourceKind.Script).length;
        if (sourceInfos.length === 0 || contractAndScriptSize === 0) {
            throw new Error('Project have no source files');
        }
        return sourceInfos.sort((a, b) => a.type - b.type);
    }
    static async compile(compilerOptionsPartial = {}, projectRootDir = '.', contractsRootDir = Project.DEFAULT_CONTRACTS_DIR, artifactsRootDir = Project.DEFAULT_ARTIFACTS_DIR, defaultFullNodeVersion = undefined, forceRecompile = false) {
        const provider = web3_1.web3.getCurrentNodeProvider();
        const fullNodeVersion = defaultFullNodeVersion ?? (await provider.infos.getInfosVersion()).version;
        const sourceFiles = await Project.loadSourceFiles(projectRootDir, contractsRootDir);
        const { errorOnWarnings, ...nodeCompilerOptions } = { ...web3_1.DEFAULT_COMPILER_OPTIONS, ...compilerOptionsPartial };
        const projectArtifact = await ProjectArtifact.from(projectRootDir);
        const changedSources = projectArtifact?.getChangedSources(sourceFiles) ?? sourceFiles.map((s) => s.name);
        if (forceRecompile ||
            projectArtifact === undefined ||
            projectArtifact.needToReCompile(nodeCompilerOptions, fullNodeVersion) ||
            changedSources.length > 0) {
            if (fs_1.default.existsSync(artifactsRootDir)) {
                removeOldArtifacts(artifactsRootDir, sourceFiles);
            }
            console.log(`Compiling contracts in folder "${contractsRootDir}"`);
            await Project.compile_(fullNodeVersion, provider, sourceFiles, projectRootDir, contractsRootDir, artifactsRootDir, errorOnWarnings, nodeCompilerOptions, changedSources, forceRecompile);
        }
        // we need to reload those contracts that did not regenerate bytecode
        return await Project.loadArtifacts(provider, sourceFiles, projectRootDir, contractsRootDir, artifactsRootDir, errorOnWarnings, nodeCompilerOptions, changedSources, forceRecompile);
    }
}
exports.Project = Project;
Project.importRegex = new RegExp('^import "[^"./]+/[^"]*[a-z][a-z_0-9]*(.ral)?"', 'mg');
Project.abstractContractMatcher = new TypedMatcher('^Abstract Contract ([A-Z][a-zA-Z0-9]*)', SourceKind.AbstractContract);
Project.contractMatcher = new TypedMatcher('^Contract ([A-Z][a-zA-Z0-9]*)', SourceKind.Contract);
Project.interfaceMatcher = new TypedMatcher('^Interface ([A-Z][a-zA-Z0-9]*)', SourceKind.Interface);
Project.scriptMatcher = new TypedMatcher('^TxScript ([A-Z][a-zA-Z0-9]*)', SourceKind.Script);
Project.structMatcher = new TypedMatcher('struct ([A-Z][a-zA-Z0-9]*)', SourceKind.Struct);
Project.matchers = [
    Project.abstractContractMatcher,
    Project.contractMatcher,
    Project.interfaceMatcher,
    Project.scriptMatcher,
    Project.structMatcher
];
Project.structArtifactFileName = 'structs.ral.json';
Project.constantArtifactFileName = 'constants.ral.json';
Project.DEFAULT_CONTRACTS_DIR = 'contracts';
Project.DEFAULT_ARTIFACTS_DIR = 'artifacts';
