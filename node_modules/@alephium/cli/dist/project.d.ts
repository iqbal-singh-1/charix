import { Artifact, Contract, Script, Struct, node, CompilerOptions, Constant, Enum } from '@alephium/web3';
declare class TypedMatcher<T extends SourceKind> {
    matcher: RegExp;
    type: T;
    constructor(pattern: string, type: T);
}
declare enum SourceKind {
    Contract = 0,
    Script = 1,
    AbstractContract = 2,
    Interface = 3,
    Struct = 4,
    Constants = 5
}
export declare class SourceInfo {
    type: SourceKind;
    name: string;
    contractRelativePath: string;
    sourceCode: string;
    sourceCodeHash: string;
    isExternal: boolean;
    getArtifactPath(artifactsRootDir: string): string;
    constructor(type: SourceKind, name: string, sourceCode: string, sourceCodeHash: string, contractRelativePath: string, isExternal: boolean);
    static from(type: SourceKind, name: string, sourceCode: string, contractRelativePath: string, isExternal: boolean): Promise<SourceInfo>;
}
declare class Compiled<T extends Artifact> {
    sourceInfo: SourceInfo;
    artifact: T;
    warnings: string[];
    constructor(sourceInfo: SourceInfo, artifact: T, warnings: string[]);
}
export declare type CodeInfo = {
    sourceFile: string;
    sourceCodeHash: string;
    bytecodeDebugPatch: string;
    codeHashDebug: string;
};
export declare class ProjectArtifact {
    static readonly artifactFileName = ".project.json";
    fullNodeVersion: string;
    compilerOptionsUsed: node.CompilerOptions;
    infos: Map<string, CodeInfo>;
    static checkCompilerOptionsParameter(compilerOptions: node.CompilerOptions): void;
    constructor(fullNodeVersion: string, compilerOptionsUsed: node.CompilerOptions, infos: Map<string, CodeInfo>);
    static isCodeChanged(current: ProjectArtifact, previous: ProjectArtifact): boolean;
    saveToFile(rootPath: string): Promise<void>;
    getChangedSources(sourceInfos: SourceInfo[]): string[];
    needToReCompile(compilerOptions: node.CompilerOptions, fullNodeVersion: string): boolean;
    static from(rootPath: string): Promise<ProjectArtifact | undefined>;
}
export declare class Project {
    sourceInfos: SourceInfo[];
    contracts: Map<string, Compiled<Contract>>;
    scripts: Map<string, Compiled<Script>>;
    structs: Struct[];
    constants: Constant[];
    enums: Enum[];
    projectArtifact: ProjectArtifact;
    readonly contractsRootDir: string;
    readonly artifactsRootDir: string;
    static readonly importRegex: RegExp;
    static readonly abstractContractMatcher: TypedMatcher<SourceKind>;
    static readonly contractMatcher: TypedMatcher<SourceKind.Contract>;
    static readonly interfaceMatcher: TypedMatcher<SourceKind.Interface>;
    static readonly scriptMatcher: TypedMatcher<SourceKind.Script>;
    static readonly structMatcher: TypedMatcher<SourceKind.Struct>;
    static readonly matchers: TypedMatcher<SourceKind>[];
    static readonly structArtifactFileName = "structs.ral.json";
    static readonly constantArtifactFileName = "constants.ral.json";
    static buildProjectArtifact(fullNodeVersion: string, sourceInfos: SourceInfo[], contracts: Map<string, Compiled<Contract>>, scripts: Map<string, Compiled<Script>>, compilerOptions: node.CompilerOptions): ProjectArtifact;
    private constructor();
    static checkCompilerWarnings(contracts: Map<string, Compiled<Contract>>, scripts: Map<string, Compiled<Script>>, globalWarnings: string[], changedSources: string[], forceRecompile: boolean, errorOnWarnings: boolean): void;
    contract(name: string): Contract;
    script(name: string): Script;
    private static loadStructs;
    private saveStructsToFile;
    private static loadConstants;
    private saveConstantsToFile;
    private static needToUpdate;
    private checkMethodIndex;
    private saveArtifactsToFile;
    private saveProjectArtifact;
    contractByCodeHash(codeHash: string): Contract;
    private static getCompileResult;
    private static compile_;
    private static loadArtifacts;
    private static getImportSourcePath;
    private static handleImports;
    private static loadSourceFile;
    private static loadSourceFiles;
    static readonly DEFAULT_CONTRACTS_DIR = "contracts";
    static readonly DEFAULT_ARTIFACTS_DIR = "artifacts";
    static compile(compilerOptionsPartial?: Partial<CompilerOptions>, projectRootDir?: string, contractsRootDir?: string, artifactsRootDir?: string, defaultFullNodeVersion?: string | undefined, forceRecompile?: boolean): Promise<Project>;
}
export {};
